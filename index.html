<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Leaflet Map</title>

    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <script src="https://unpkg.com/leaflet.heat/dist/leaflet-heat.js"></script>

    <style>
        #map {
            height: 100vh;
            width: 100%;
        }

        #sidebar {
    position: fixed;
    top: 0;
    right: -350px; 
    width: 320px;
    height: 100vh;
    background: #ffffff;
    box-shadow: -4px 0 15px rgba(0,0,0,0.2);
    padding: 20px;
    transition: 0.35s;
    overflow-y: auto;
    font-family: Arial;
    z-index: 9999;

}

#sidebar.open {
    right: 0;
}

#sidebar h2 {
    margin-top: 0;
    font-size: 22px;
}

#risk-score {
    font-size: 18px;
    font-weight: bold;
    margin-bottom: 15px;
}
#route-box {
    position: absolute;
    top: 10px;
    left: 10px;
    z-index: 9999;
    background: white;
    padding: 10px;
    border-radius: 10px;
    box-shadow: 0 3px 8px rgba(0,0,0,0.3);
}

#route-box input {
    width: 160px;
    margin: 4px 0;
    padding: 6px;
}

    </style>
</head>
<body>

<div id="map"></div>

<div id="sidebar">
    <button id="closeSidebar" style="
    float:right;
    font-size:18px;
    border:none;
    background:none;
    cursor:pointer;
">‚úï</button>

    <h2>üìä Risk Insights</h2>
    <p id="risk-score">Click anywhere on map</p>
    <div id="risk-details"></div>
    <div id="risk-advice"></div>
</div>

<!--routing-->
<div id="route-box">
    <input id="start" placeholder="Start location" />
    <input id="end" placeholder="End location" />
    <button onclick="getRouteMultiple()">Find Route</button>
</div>

<script>

let acc = [];
let crime = [];
let poll = [];
let traffic = [];
let wifi = [];
let hosp = [];



const heatStyle = {
    radius: 60,
    blur: 35,
    maxZoom: 17,
    minOpacity: 0.4,
    gradient: {
        0.2: "blue",
        0.4: "cyan",
        0.6: "lime",
        0.8: "yellow",
        1.0: "red"
    }
};

const map = L.map("map");

L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
    maxZoom: 19
}).addTo(map);


Promise.all([
    fetch("accidents.json").then(r => r.json()),
    fetch("crime.json").then(r => r.json()),
    fetch("pollution.json").then(r => r.json()),
    fetch("traffic.json").then(r => r.json()),
    fetch("wifi.json").then(r => r.json()),
    fetch("hospital.json").then(r => r.json())
]).then(([accData, crimeData, pollData, trafficData, wifiData, hospData]) => {

    // assign globally
    acc = accData;
    crime = crimeData;
    poll = pollData;
    traffic = trafficData;
    wifi = wifiData;
    hosp = hospData;


    // CREATE HEATLAYERS
    const accidentLayer = L.heatLayer(acc.map(d => [d.lat, d.lng, d.value]), heatStyle);
    const crimeLayer = L.heatLayer(crime.map(d => [d.lat, d.lng, d.value]), heatStyle);
    const pollutionLayer = L.heatLayer(poll.map(d => [d.lat, d.lng, d.value]), heatStyle);
    const trafficLayer = L.heatLayer(traffic.map(d => [d.lat, d.lng, d.value]), heatStyle);
    const wifiLayer = L.heatLayer(wifi.map(d => [d.lat, d.lng, d.value]), heatStyle);
    const hospitalLayer = L.heatLayer(hosp.map(d => [d.lat, d.lng, d.value]), heatStyle);


    // üî• COMBINED RISK LAYER
    combinedPoints = [];

    const maxLen = Math.min(acc.length, crime.length, poll.length, traffic.length, wifi.length, hosp.length);

    for (let i = 0; i < maxLen; i++) {
        if (!acc[i]?.lat || !acc[i]?.lng) continue;

        const combinedValue =
            (acc[i]?.value || 0) * 0.25 +
            (crime[i]?.value || 0) * 0.20 +
            (traffic[i]?.value || 0) * 0.20 +
            (poll[i]?.value || 0) * 0.15 +
            (hosp[i]?.value || 0) * 0.10 +
            (wifi[i]?.value || 0) * 0.10;

        combinedPoints.push([acc[i].lat, acc[i].lng, combinedValue]);
    }

    const combinedLayer = L.heatLayer(combinedPoints, heatStyle);

    // Fit map to full data extent
    map.fitBounds(combinedPoints.map(p => [p[0], p[1]]));


    // ‚≠ê TOOLTIP HOVER LAYERGROUPS
    const accidentHover = L.layerGroup().addTo(map);
    const crimeHover = L.layerGroup().addTo(map);
    const trafficHover = L.layerGroup().addTo(map);
    const pollutionHover = L.layerGroup().addTo(map);
    const hospitalHover = L.layerGroup().addTo(map);
    const combinedHover = L.layerGroup().addTo(map);

    // Helper for hover markers
    function addHoverMarkers(dataset, layer, label) {
        dataset.forEach(p => {
            L.circleMarker([p.lat, p.lng], {
                radius: 8,
                color: "transparent",
                fillColor: "transparent",
                fillOpacity: 0.05
            })
            .bindTooltip(`${label}: ${p.value}`, { permanent: false })
            .addTo(layer);
        });
    }

    
addHoverMarkers(acc, accidentHover, "Accidents");
addHoverMarkers(crime, crimeHover, "Crime Rate");
addHoverMarkers(traffic, trafficHover, "Traffic Level");
addHoverMarkers(poll, pollutionHover, "Pollution Index");
addHoverMarkers(hosp, hospitalHover, "Hospital Load");
addHoverMarkers(
  combinedPoints.map(p => ({ lat: p[0], lng: p[1], value: p[2] })),
  combinedHover,
  "Combined Risk"
);


//on click pop up menu


// CLICK EVENT ‚Üí Show risk popup
map.on("click", (e) => {
    const { lat, lng } = e.latlng;

    const a = getClosestPoint(acc, lat, lng)?.value || 0;
    const c = getClosestPoint(crime, lat, lng)?.value || 0;
    const t = getClosestPoint(traffic, lat, lng)?.value || 0;
    const p = getClosestPoint(poll, lat, lng)?.value || 0;
    const h = getClosestPoint(hosp, lat, lng)?.value || 0;
    const w = getClosestPoint(wifi, lat, lng)?.value || 0;

    const combined =
        a * 0.25 +
        c * 0.20 +
        t * 0.20 +
        p * 0.15 +
        h * 0.10 +
        w * 0.10;

    const popupHTML = `
        <b>üìç Risk Analysis for Selected Location</b><br><br>
        üöß Accidents: <b>${a}</b><br>
        üõë Crime: <b>${c}</b><br>
        üö¶ Traffic: <b>${t}</b><br>
        üè≠ Pollution: <b>${p}</b><br>
        üè• Hospital Load: <b>${h}</b><br>
        üì∂ WiFi Score: <b>${w}</b><br><br>
        üî• <b>Total Risk Score: ${combined.toFixed(2)}</b>
    `;

    L.popup()
        .setLatLng([lat, lng])
        .setContent(popupHTML)
        .openOn(map);

    // Open the sidebar
document.getElementById("sidebar").classList.add("open");

// Update score
document.getElementById("risk-score").innerHTML =
    `üî• Combined Risk: <b>${combined.toFixed(2)}</b>`;

// Update breakdown
document.getElementById("risk-details").innerHTML = `
    <p><b>Accidents:</b> ${a.toFixed(2)}</p>
    <p><b>Crime:</b> ${c.toFixed(2)}</p>
    <p><b>Traffic:</b> ${t.toFixed(2)}</p>
    <p><b>Pollution:</b> ${p.toFixed(2)}</p>
    <p><b>Hospital Load:</b> ${h.toFixed(2)}</p>
    <p><b>Wi-Fi Quality:</b> ${w.toFixed(2)}</p>
`;

// Recommendations
document.getElementById("risk-advice").innerHTML = getAdvice(combined);

});


function getAdvice(score) {
    if (score > 0.75) {
        return "<p style='color:red'><b>‚ö† High Risk Area:</b> Avoid if possible. Drive carefully.</p>";
    }
    if (score > 0.50) {
        return "<p style='color:orange'><b>Moderate Risk:</b> Stay alert, some issues detected.</p>";
    }
    return "<p style='color:green'><b>Low Risk:</b> Safe zone, normal conditions.</p>";
}
document.getElementById("closeSidebar").onclick = () =>
    document.getElementById("sidebar").classList.remove("open");




    // LAYER CONTROL
    const overlays = {
        "Accidents": accidentLayer,
        "Crime": crimeLayer,
        "Pollution": pollutionLayer,
        "Traffic": trafficLayer,
        "WiFi Strength": wifiLayer,
        "Hospital Load": hospitalLayer,
        "üî• Combined Risk": combinedLayer,

        // Hover layers
        "‚ÑπÔ∏è Accidents Info": accidentHover,
        "‚ÑπÔ∏è Crime Info": crimeHover,
        "‚ÑπÔ∏è Traffic Info": trafficHover,
        "‚ÑπÔ∏è Pollution Info": pollutionHover,
        "‚ÑπÔ∏è Hospital Info": hospitalHover,
        "‚ÑπÔ∏è Combined Info": combinedHover
    };

    L.control.layers(null, overlays).addTo(map);

});


// USER LOCATION
map.locate({ setView: true, maxZoom: 16, enableHighAccuracy: true });

map.on("locationfound", e => {
    L.marker(e.latlng).addTo(map).bindPopup("üìç Your Location").openPopup();
});

map.on("locationerror", () => {
    alert("Unable to find location. Showing India.");
    map.setView([20.5937, 78.9629], 5);
});


let combinedPoints = []; // make it global


// üü¢ Get nearest combined risk for a given point
function getNearestRisk(lat, lng) {
    let minDist = Infinity;
    let nearestRisk = 0;

    combinedPoints.forEach(p => {
        const dLat = lat - p[0];
        const dLng = lng - p[1];
        const dist = Math.sqrt(dLat * dLat + dLng * dLng);

        if (dist < minDist) {
            minDist = dist;
            nearestRisk = p[2]; // combined risk value
        }
    });

    return nearestRisk;
}
//Calculate Route Risk
function analyzeRouteRisk(points) {
    let totalRisk = 0;
    let closestPoints = []; 

    points.forEach(p => {
        const lat = p[1];
        const lng = p[0];
        const risk = getNearestRisk(lat, lng);

        closestPoints.push(risk);
        totalRisk += risk;
    });

    const avgRisk = totalRisk / points.length;

    // üî• Open the sidebar automatically
    document.getElementById("sidebar").classList.add("open");

    // Risk components (estimated for route)
    const a = avgRisk * 0.30;
    const c = avgRisk * 0.20;
    const t = avgRisk * 0.20;
    const p = avgRisk * 0.15;
    const h = avgRisk * 0.10;
    const w = avgRisk * 0.05;

    // Update score
    document.getElementById("risk-score").innerHTML =
        `üöó Route Risk Score: <b>${avgRisk.toFixed(2)}</b>`;

    // Update breakdown
    document.getElementById("risk-details").innerHTML = `
        <p><b>Accidents:</b> ${a.toFixed(2)}</p>
        <p><b>Crime:</b> ${c.toFixed(2)}</p>
        <p><b>Traffic:</b> ${t.toFixed(2)}</p>
        <p><b>Pollution:</b> ${p.toFixed(2)}</p>
        <p><b>Hospital Load:</b> ${h.toFixed(2)}</p>
        <p><b>Wi-Fi Quality:</b> ${w.toFixed(2)}</p>
    `;

    // Advice
    document.getElementById("risk-advice").innerHTML = getAdvice(avgRisk);
}


function getDistance(lat1, lon1, lat2, lon2) {
    const R = 6371;
    const dLat = (lat2 - lat1) * Math.PI / 180;
    const dLon = (lon2 - lon1) * Math.PI / 180;

    const a =
        Math.sin(dLat / 2)**2 +
        Math.cos(lat1 * Math.PI / 180) *
        Math.cos(lat2 * Math.PI / 180) *
        Math.sin(dLon / 2)**2;

    return R * (2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a)));
}



//Fetch Route Using OSRM API
// Fetch multiple routes (OSRM alternatives)
async function getRouteMultiple() {
    const startText = document.getElementById("start").value;
    const endText = document.getElementById("end").value;
    if (!startText || !endText) return alert("Enter start & end location");

    const s = await geocode(startText);
    const e = await geocode(endText);
    if (!s || !e) return alert("Location not found");

    // alternatives=true requests multiple routes from OSRM
    const url = `https://router.project-osrm.org/route/v1/driving/${s.lng},${s.lat};${e.lng},${e.lat}?overview=full&geometries=geojson&alternatives=true`;

    const res = await fetch(url);
    const data = await res.json();

    // data.routes is an array of route objects
    if (!data || !data.routes || data.routes.length === 0) {
        return alert("No routes returned");
    }

    processRoutes(data.routes);
}


//Basic Geocoder (Turn any text ‚Üí Coordinates)
async function geocode(place) {
    const url = `https://nominatim.openstreetmap.org/search?format=json&q=${place}`;
    const res = await fetch(url);
    const data = await res.json();

    return {
        lat: parseFloat(data[0].lat),
        lng: parseFloat(data[0].lon)
    };
}

// Find closest point from dataset
function getClosestPoint(dataset, lat, lng) {
    let closest = null;
    let minDist = Infinity;

    dataset.forEach(p => {
        const dist = getDistance(lat, lng, p.lat, p.lng);
        if (dist < minDist) {
            minDist = dist;
            closest = p;
        }
    });

    return closest;
}


function computeRiskForRoute(routeCoords) {
    // routeCoords: array of [lng, lat] OR objects; sample them first
    const sampled = sampleRouteCoords(routeCoords, 10);

    let accSum=0, crimeSum=0, trafficSum=0, pollSum=0, hospSum=0, wifiSum=0;
    sampled.forEach(pt => {
        const lat = pt.lat;
        const lng = pt.lng;

        accSum     += getClosestPoint(acc, lat, lng)?.value || 0;
        crimeSum   += getClosestPoint(crime, lat, lng)?.value || 0;
        trafficSum += getClosestPoint(traffic, lat, lng)?.value || 0;
        pollSum    += getClosestPoint(poll, lat, lng)?.value || 0;
        hospSum    += getClosestPoint(hosp, lat, lng)?.value || 0;
        wifiSum    += getClosestPoint(wifi, lat, lng)?.value || 0;
    });

    const n = sampled.length || 1;
    const accAvg = accSum / n;
    const crimeAvg = crimeSum / n;
    const trafficAvg = trafficSum / n;
    const pollAvg = pollSum / n;
    const hospAvg = hospSum / n;
    const wifiAvg = wifiSum / n;

    const combined =
        accAvg * 0.25 +
        crimeAvg * 0.20 +
        trafficAvg * 0.20 +
        pollAvg * 0.15 +
        hospAvg * 0.10 +
        wifiAvg * 0.10;

    return {
        accAvg, crimeAvg, trafficAvg, pollAvg, hospAvg, wifiAvg, combined, sampled
    };
}

// global holders
let routeLayers = []; // L.geoJSON layers for routes
let routesInfo = [];  // metadata for sidebar

async function processRoutes(osrmRoutes) {
    // clear previous
    routeLayers.forEach(l => map.removeLayer(l));
    routeLayers = [];
    routesInfo = [];

    // For each returned route compute metrics
    for (let i = 0; i < osrmRoutes.length; i++) {
        const r = osrmRoutes[i];

        // OSRM geometry: GeoJSON LineString coordinates array [lng,lat]
        const coords = r.geometry.coordinates;
        const risk = computeRiskForRoute(coords);

        // convert duration, distance
        const durationMin = Math.round(r.duration / 60);
        const distanceKm = (r.distance / 1000).toFixed(2);

        const info = {
            index: i,
            coords,
            durationMin,
            distanceKm,
            risk
        };
        routesInfo.push(info);
    }

    // pick recommended: smallest combined risk
    routesInfo.sort((a,b) => a.risk.combined - b.risk.combined);
    const recommendedIndex = routesInfo[0].index;

    // render on map and sidebar
    renderRoutes(routesInfo, recommendedIndex);
    updateSidebarRoutes(routesInfo, recommendedIndex);
}

function renderRoutes(routesInfo, recommendedIndex) {
    // remove existing
    routeLayers.forEach(l => map.removeLayer(l));
    routeLayers = [];

    routesInfo.forEach(info => {
        const geo = {
            "type": "Feature",
            "geometry": {
                "type": "LineString",
                "coordinates": info.coords
            }
        };

        const color = (info.index === recommendedIndex) ? "#22c55e" : "#888888";
        const weight = (info.index === recommendedIndex) ? 6 : 4;
        const opacity = (info.index === recommendedIndex) ? 1 : 0.6;

        const layer = L.geoJSON(geo, {
            style: { color, weight, opacity }
        }).addTo(map);

        // store reference
        routeLayers.push({ layer, index: info.index });

        // click to show details & highlight
        layer.on('click', () => {
            highlightRoute(info.index);
            showRouteDetailsInSidebar(info);
        });
    });

    // fit map to first route bounds for user clarity
    if (routesInfo.length) {
        const firstLayer = routeLayers[0].layer;
        map.fitBounds(firstLayer.getBounds(), { padding: [40, 40] });
    }
}

function highlightRoute(index) {
    routeLayers.forEach(obj => {
        const isActive = (obj.index === index);
        obj.layer.setStyle({
            color: isActive ? "#ef4444" : "#888888",   // active red, others grey
            weight: isActive ? 7 : 4,
            opacity: isActive ? 1 : 0.5
        });
    });
}

function updateSidebarRoutes(routesInfo, recommendedIndex) {
    // Build HTML
    let html = `<h3>Route options</h3><div class="routes-list">`;
    routesInfo.forEach(info => {
        const r = info.risk;
        let riskLabel = (r.combined < 0.4) ? "Low" : (r.combined < 0.7) ? "Medium" : "High";
        let color = (riskLabel === "Low") ? "green" : (riskLabel === "Medium") ? "orange" : "red";
        const recommended = (info.index === recommendedIndex) ? " <strong>‚≠ê Recommended</strong>" : "";

        html += `
            <div class="route-item" data-idx="${info.index}" style="margin-bottom:8px; padding:8px; border-radius:6px; background:#fff; box-shadow:0 1px 3px rgba(0,0,0,0.06);">
                <div><b>Route ${info.index + 1}</b>${recommended}</div>
                <div>${info.durationMin} min ‚Ä¢ ${info.distanceKm} km</div>
                <div>Risk: <span style="color:${color}">${r.combined.toFixed(2)} (${riskLabel})</span></div>
            </div>
        `;
    });
    html += `</div><hr>`;
    document.getElementById("risk-details").innerHTML = html;

    // attach click listeners
    document.querySelectorAll(".route-item").forEach(el => {
        el.addEventListener("click", () => {
            const idx = Number(el.dataset.idx);
            const selected = routesInfo.find(r => r.index === idx);
            highlightRoute(idx);
            showRouteDetailsInSidebar(selected);
        });
    });

    // open sidebar
    document.getElementById("sidebar").classList.add("open");
}


function showRouteDetailsInSidebar(info) {
    const r = info.risk;
    // show main score at top
    document.getElementById("risk-score").innerHTML = `üî• Route ${info.index + 1} Combined Risk: <b>${r.combined.toFixed(2)}</b>`;

    // show breakdown & advice below (append)
    const breakdownHtml = `
        <p><b>Accidents:</b> ${r.accAvg.toFixed(2)}</p>
        <p><b>Crime:</b> ${r.crimeAvg.toFixed(2)}</p>
        <p><b>Traffic:</b> ${r.trafficAvg.toFixed(2)}</p>
        <p><b>Pollution:</b> ${r.pollAvg.toFixed(2)}</p>
        <p><b>Hospital:</b> ${r.hospAvg.toFixed(2)}</p>
        <p><b>WiFi:</b> ${r.wifiAvg.toFixed(2)}</p>
    `;
    document.getElementById("risk-details").innerHTML = breakdownHtml;

    document.getElementById("risk-advice").innerHTML = getAdvice(r.combined);
    document.getElementById("sidebar").classList.add("open");
}


// simple sampler: pick one every N points to control workload
function sampleRouteCoords(coords, step = 10) {
    // coords: array of [lng, lat] or {lat,lng} depending on source ‚Äî normalize
    const points = [];
    for (let i = 0; i < coords.length; i += step) {
        const c = coords[i];
        // OSRM geojson uses [lng, lat]
        const lat = (c.lat !== undefined) ? c.lat : c[1];
        const lng = (c.lng !== undefined) ? c.lng : c[0];
        points.push({ lat, lng });
    }
    return points;
}



</script>

</body>
</html>




